{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/Util.js","webpack:///./src/core/CanvasRenderer.js","webpack:///./src/core/Delta.js","webpack:///./src/core/EventBus.js","webpack:///./src/core/GameEngine.js","webpack:///./src/core/GameEvent.js","webpack:///./src/core/GameInput.js","webpack:///./src/core/SubsystemManager.js","webpack:///./src/index.js","webpack:///./src/subsystems/PlayerSubsystem.js","webpack:///./src/subsystems/entities/BoundingBox.js","webpack:///./src/subsystems/entities/Entity.js","webpack:///./src/subsystems/entities/EntityFactory.js","webpack:///./src/subsystems/entities/Point.js","webpack:///./src/subsystems/entities/Shape.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA,C;;;;;;;;;;;;;;AC/BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,C;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uDAAuD,4BAA4B;AACnF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,oBAAoB;AACpB;AACA;AACA,C;;;;;;;;;;;;;;;AC1EkB;;AAElB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;;;;ACP4B;;AAE5B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;ACrCiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;;;;ACnCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mB;;;;;;;;;;;;;;;;;;ACTA;AACA;AAC4B;AACX;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzCkB;AAClB;;AAEA;;AAEA;AACA,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;;;ACvCA;AACkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD,aAAa;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;;;ACbkB;;AAElB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,C;;;;;;;;;;;;;;;;;ACtCA;AACA;AACc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","export function immutable(object, property, value) {\n    Object.defineProperties(object,\n        {\n            [property]: {\n                writeable: false,\n                enumerable: true,\n                value: value\n\n            }\n        });\n}\n\nexport function isNum(value) {\n    return !(isNaN(value) ||\n        value === undefined ||\n        value === null);\n}\n\nexport function autobind(clazz, self) {\n    Object.getOwnPropertyNames(clazz)\n        .forEach(prop => {\n            self[prop] = self[prop].bind(self);\n        });\n}\n\nexport function loadArray(length, defaultValue) {\n    let newArray = [];\n    for (let i = 0; i <= length; i++) {\n        newArray.push(defaultValue);\n    }\n    return newArray;\n}","export default class CanvasRenderer {\n\n    constructor(canvasContext) {\n        this._canvasContext = canvasContext;\n        this._color = '#FFFFFF';\n        this._font = '12px monospace';\n        this._canvasContext.fillStyle = this._color;\n        this._canvasContext.strokeStyle = this._color;\n        this._canvasContext.font = this._font;\n    }\n\n    setColor(newColor) {\n        this._color = newColor;\n    }\n\n    setFont(newFont) {\n        this._font = newFont;\n    }\n\n    drawText(x, y, text) {\n        this._canvasContext.fillStyle = this._color;\n        this._canvasContext.font = this._font;\n        this._canvasContext.fillText(text, x, y);\n    }\n\n    fillRectangle(x, y, w, h) {\n        this._canvasContext.fillStyle = this._color;\n        this._canvasContext.fillRect(x, y, w, h);\n    }\n\n    drawLine(x1, y1, x2, y2) {\n        this._canvasContext.strokeStyle = this._color;\n        this._canvasContext.beginPath();\n        this._canvasContext.moveTo(x1, y1);\n        this._canvasContext.lineTo(x2, y2);\n        this._canvasContext.stroke();\n\n    }\n\n    clearCanvas(color) {\n        this._canvasContext.fillStyle = color;\n        const w = this._canvasContext.canvas.width;\n        const h = this._canvasContext.canvas.height;\n        this._canvasContext.fillRect(0, 0, w, h);\n    }\n}","export default class Delta {\n    constructor(options) {\n        this._config = options.config;\n        this._lastFrame = 0;\n    }\n\n    getInterval() {\n        const currentTime = new Date().getTime();\n        const elapsed = currentTime - this._lastFrame;\n        let delta = elapsed / (1000 / this._config.fps);\n        this._lastFrame = currentTime;\n        delta = Math.min(10, delta);\n        return {delta: delta, milliseconds: elapsed};\n    }\n}","export default class EventBus {\n    constructor() {\n        this._pendingEvents = [];\n        this._subscribers = {};\n    };\n\n    enqueue(event) {\n        this._pendingEvents.push(event);\n    }\n\n    subscribe(eventType, subscriber) {\n        if (!this._subscribers[eventType]) {\n            this._subscribers[eventType] = [];\n        }\n        this._subscribers[eventType].push(subscriber);\n    }\n\n    unsubscribe(eventType, subscriberToRemove) {\n        const subscribers = this._subscribers[eventType];\n        const indexOf = subscribers.indexOf(subscriberToRemove);\n        if (indexOf !== -1) {\n            subscribers.splice(indexOf, 1);\n        }\n    }\n\n    process() {\n        const self = this;\n        const allEvents = this._pendingEvents;\n        this._pendingEvents = [];\n        allEvents.forEach((event) => {\n            const subscribers = self._subscribers[event.type];\n            if (subscribers) {\n                subscribers.forEach((subscriber) => {\n                    subscriber(event);\n                });\n            }\n        });\n    }\n}","import GameInput from \"./GameInput\";\nimport EventBus from \"./EventBus\";\nimport CanvasRenderer from \"./CanvasRenderer\";\nimport Delta from \"./Delta\";\nimport SubsystemManager from \"./SubsystemManager\";\nimport {autobind} from \"../Util\";\n\nexport default class GameEngine {\n\n    constructor(config) {\n        autobind(GameEngine.prototype, this);\n        this._delta = GameEngine._createDelta(config);\n        this.subsystems = config.subsystems;\n        this._input = new GameInput();\n        this._eventBus = new EventBus();\n        this._subsystemManager = new SubsystemManager();\n        config.subsystems.forEach(this._subsystemManager.addSubsystem);\n\n        this._canvas = GameEngine._getCanvas(config.canvasId);\n        this._renderer = new CanvasRenderer(this._canvas);\n    }\n\n    start() {\n        let gameContainer = this._createGameContainer({delta: 1.0, milliseconds: 0});\n        this._subsystemManager.initialize(gameContainer);\n        window.setInterval(this.cycle.bind(this), 1000 / 60);\n    }\n\n    cycle() {\n        const interval = this._delta.getInterval();\n        let gameContainer = this._createGameContainer(interval);\n        this._eventBus.process();\n        this._subsystemManager.update(gameContainer);\n        this._renderer.clearCanvas('#000000');\n        this._subsystemManager.render(gameContainer);\n    }\n\n    _createGameContainer(interval) {\n        return {\n            delta: interval.delta,\n            timeSinceLastFrame: interval.milliseconds,\n            input: this._input,\n            audio: {},\n            display: {\n                width: this._canvas.canvas.width,\n                height: this._canvas.canvas.height\n            },\n            addEntity: () => {\n            },\n            events: {\n                emit: this._eventBus.enqueue,\n                subscribe: this._eventBus.subscribe,\n                unsubscribe: this._eventBus.unsubscribe\n            }\n        };\n    }\n\n    static _createDelta(config) {\n        return new Delta({\n            time: new Date().getTime(),\n            config: {\n                fps: config.fps\n            }\n        });\n    }\n\n    static _getCanvas(canvasId) {\n        const canvasElement = document.getElementById(canvasId);\n        if (canvasElement) {\n            return canvasElement.getContext('2d');\n        } else {\n            return {width: 0, height: 0};\n        }\n    }\n}","import {immutable} from \"../Util\";\n\nexport default class GameEvent {\n    constructor(type, data) {\n        immutable(this, 'type', type);\n        immutable(this, 'data', data);\n    }\n}","import {autobind, loadArray} from \"../Util\";\n\nexport const KEY_LEFT = 37;\nexport const KEY_UP = 38;\nexport const KEY_RIGHT = 39;\nexport const KEY_DOWN = 40;\nexport const KEY_SPACEBAR = 32;\n\nexport default class GameInput {\n\n    constructor() {\n        autobind(GameInput.prototype, this);\n        this._keyStates = loadArray(255, false);\n        this.blockedKeys = [KEY_LEFT, KEY_RIGHT, KEY_UP, KEY_DOWN, KEY_SPACEBAR];\n        document.addEventListener('keyup', this._keyUp.bind(this));\n        document.addEventListener('keydown', this._keyDown.bind(this));\n    }\n\n    isPressed(keyCode) {\n        return this._keyStates[keyCode];\n    }\n\n    _keyUp(event) {\n        this._keyStates[event.keyCode] = false;\n        this._supressGameKeys(event);\n    }\n\n    _keyDown(event) {\n        this._keyStates[event.keyCode] = true;\n        this._supressGameKeys(event);\n    }\n\n    _supressGameKeys(event) {\n        if (this.blockedKeys.indexOf(event.keyCode) !== -1) {\n            event.preventDefault();\n        }\n    }\n}","import {autobind} from \"../Util\";\n\nexport default class SubsystemManager {\n    constructor() {\n        this._subsystems = [];\n        autobind(SubsystemManager.prototype, this);\n    }\n\n    addSubsystem(subsystem) {\n        this._subsystems.push(subsystem);\n    }\n\n    initialize(gameContainer) {\n        this._subsystems.forEach(subsystem => {\n            if (subsystem.initialize) {\n                subsystem.initialize(gameContainer);\n            }\n        });\n    }\n\n    update(updateContainer) {\n        this._subsystems.forEach((subsystem) => {\n            if (subsystem.update) {\n                subsystem.update(updateContainer);\n            }\n        });\n    }\n\n    render(renderer) {\n        this._subsystems.forEach((subsystem) => {\n            if (subsystem.render) {\n                subsystem.render(renderer);\n            }\n        });\n    }\n}","import GameEngine from \"./core/GameEngine\";\nimport PlayerSubsystem from \"./subsystems/PlayerSubsystem\";\n\nconst gameConfig = {\n    fps: 30,\n    canvasId: 'game-canvas',\n    subsystems: [new PlayerSubsystem()]\n};\nconst gameEngine = new GameEngine(gameConfig);\ngameEngine.start();","import * as EntityFactory from \"./entities/EntityFactory\";\nimport Point from \"./entities/Point\";\nimport {KEY_LEFT, KEY_RIGHT} from \"../core/GameInput\";\nimport {autobind} from \"../Util\";\n\nvar MOVE_SPEED = 5.0;\nvar ACCELLERATION = 0.125;\n\nexport default class PlayerSubsystem {\n    constructor(config) {\n        autobind(PlayerSubsystem.prototype, this);\n        // this._timer = config.time;\n        this._playerWeaponDelay = 100;\n        this._lastWeaponDischarge = 0;\n    }\n\n    initialize(gameContainer) {\n        this._respawnPlayer(gameContainer)\n    }\n\n    render() {\n    }\n\n    update(gameContainer) {\n        this._handleMovement(gameContainer);\n    }\n\n    _handleMovement(gameContainer) {\n        const input = gameContainer.input;\n        if (input.isPressed(KEY_LEFT)) {\n            this._player.position.translate(new Point(-MOVE_SPEED, 0));\n        }\n        if (input.isPressed(KEY_RIGHT)) {\n            this._player.position.translate(new Point(MOVE_SPEED, 0));\n        }\n    }\n\n    _respawnPlayer(gameContainer) {\n        this._player = EntityFactory.buildPlayer(new Point(320, 240));\n        gameContainer.addEntity(this._player);\n    }\n}\n","import {immutable} from \"../../Util\";\nimport Point from \"./Point\";\n\nexport default class BoundingBox {\n\n    constructor(minP, maxP) {\n        const {min, max} = this._sort(minP, maxP);\n        immutable(this, 'min', min);\n        immutable(this, 'max', max);\n    }\n\n    _sort(min, max) {\n        const minX = Math.min(min.x, max.x);\n        const minY = Math.min(min.y, max.y);\n        const maxX = Math.max(min.x, max.x);\n        const maxY = Math.max(min.y, max.y);\n        min = new Point(minX, minY);\n        max = new Point(maxX, maxY);\n        return {min, max};\n    }\n\n    intersects(otherBox) {\n        if (!otherBox || !(otherBox instanceof BoundingBox)) {\n            throw new Error('Intersect cannot be calculated on a non-BoundingBox object');\n        }\n        if (otherBox.max.x < this.min.x) {\n            return false;\n        }\n        if (otherBox.min.x > this.max.x) {\n            return false;\n        }\n        if (otherBox.max.y < this.min.y) {\n            return false;\n        }\n        if (otherBox.min.y > this.max.y) {\n            return false;\n        }\n        return true;\n    }\n}","import Point from \"./Point\";\nimport {immutable} from \"../../Util\";\nimport GameEvent from \"../../core/GameEvent\";\n\nexport default class Entity {\n    constructor(shape, type) {\n        immutable(this, 'shape', shape);\n        immutable(this, 'type', type);\n        this._behaviors = [];\n        this._isAlive = true;\n        this.position = new Point(0, 0);\n        this.velocity = new Point(0, 0);\n    }\n\n    get rotation() {\n        return this.shape.rotation;\n    }\n\n    set rotation(value) {\n        this.shape.rotation = value;\n    }\n\n    get position() {\n        return this.shape.position;\n    }\n\n    set position(value) {\n        this.shape.position = value;\n    }\n\n    get isAlive() {\n        return this._isAlive;\n    }\n\n    render(renderer) {\n        this.shape.render(renderer);\n    };\n\n    update(gameContainer) {\n        this._invokeBehaviors(gameContainer);\n        const vX = this.velocity.x * gameContainer.delta;\n        const vY = this.velocity.y * gameContainer.delta;\n        this.position = this.position.translate({x: vX, y: vY});\n    };\n\n    destroy(gameContainer) {\n        this._isAlive = false;\n        gameContainer.events.emit(new GameEvent('entity-death', {\n            type: this.type,\n            position: this.position\n        }));\n    };\n\n    addBehavior(newBehavior) {\n        this._behaviors.push(newBehavior);\n    }\n\n    _invokeBehaviors(gameContainer) {\n        const entity = this;\n        this._behaviors.forEach(function (behavior) {\n            behavior(gameContainer, entity);\n        });\n    }\n}","import Shape from \"./Shape\";\nimport Point from \"./Point\";\nimport Entity from \"./Entity\";\n\nexport function buildPlayer(location) {\n    const player = new Entity(new Shape([\n        new Point(-5, -5),\n        new Point(0, -5),\n        new Point(5, -5),\n        new Point(0, 5),\n    ]), 'player');\n    player.position = location;\n    return player;\n}","import {immutable} from \"../../Util\";\n\nexport default class Point {\n    constructor(x, y) {\n        immutable(this, 'x', x);\n        immutable(this, 'y', y);\n    }\n\n    translate(otherPoint) {\n        return new Point(this.x + otherPoint.x, this.y + otherPoint.y);\n    }\n\n    scale(multiplier) {\n        return new Point(this.x * multiplier, this.y * multiplier);\n    }\n\n    get magnitude() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    get normalize() {\n        const magnitude = this.magnitude();\n        const x = this.x / magnitude;\n        const y = this.y / magnitude;\n        return new Point(x, y);\n    }\n\n    rotate(degrees) {\n        const theta = degrees * Math.PI / 180.0;\n        const x = Math.cos(theta) * this.x - Math.sin(theta) * this.y;\n        const y = Math.sin(theta) * this.x + Math.cos(theta) * this.y;\n        return new Point(x, y);\n    }\n\n    get toString() {\n        return 'Point(' + this.x + ', ' + this.y + ')';\n    }\n\n}","import Point from \"./Point\";\nimport BoundingBox from \"./BoundingBox\";\nimport {isNum} from \"../../Util\";\n\nexport default class Shape {\n    constructor(points) {\n        this._points = points;\n        this.color = '#ffffff';\n        this.rotation = 0;\n        this.position = new Point(0, 0);\n    }\n\n    boundingBox() {\n        let minX = Number.MAX_VALUE;\n        let minY = Number.MAX_VALUE;\n        let maxX = Number.MIN_VALUE;\n        let maxY = Number.MIN_VALUE;\n        this._points.forEach((point) => {\n            minX = (point.x < minX) ? point.x : minX;\n            minY = (point.y < minY) ? point.y : minY;\n            maxX = (point.x > maxX) ? point.x : maxX;\n            maxY = (point.y > maxY) ? point.y : maxY;\n        });\n        return new BoundingBox(\n            new Point(minX, minY),\n            new Point(maxX, maxY)\n        );\n    }\n\n    getPoints() {\n        const rotation = this.rotation;\n        const position = this.position;\n        return this._points.map((point) => {\n            point = point.rotate(rotation);\n            const x = point.x + position.x;\n            const y = point.y + position.y;\n            return new Point(x, y);\n        });\n    }\n\n    contains(pointToCheck) {\n        const points = this.getPoints();\n        const totalPoints = this._points.length;\n        const x = pointToCheck.x;\n        const y = pointToCheck.y;\n        if (!isNum(x) || !isNum(y)) {\n            return false;\n        }\n        let isContained = false;\n        for (let i = 0, j = totalPoints - 1; i < totalPoints; j = i++) {\n            const x1 = points[i].x;\n            const y1 = points[i].y;\n            const x2 = points[j].x;\n            const y2 = points[j].y;\n\n            const intersect = ((y1 > y) !== (y2 > y))\n                && (x < (x2 - x1) * (y - y1) / (y2 - y1) + x1);\n            if (intersect) isContained = !isContained;\n        }\n\n        return isContained;\n    }\n\n    intersects(otherShape) {\n        if (!(otherShape instanceof Shape)) {\n            return false;\n        }\n        let intersects = false;\n        const self = this;\n        const points = otherShape.getPoints();\n        points.forEach(function (otherPoint) {\n            if (self.contains(otherPoint)) {\n                intersects = true;\n            }\n        });\n        return intersects;\n    }\n\n    render(renderer) {\n        renderer.setColor(this.color);\n        const rotatedPoints = this.getPoints();\n        const totalPoints = rotatedPoints.length;\n        let p1, p2;\n        for (let i = 0; i < totalPoints - 1; i++) {\n            p1 = rotatedPoints[i];\n            p2 = rotatedPoints[i + 1];\n            _drawLine(renderer, p1, p2);\n\n        }\n        p1 = rotatedPoints[totalPoints - 1];\n        p2 = rotatedPoints[0];\n        renderer.drawLine(p1.x, p1.y, p2.x, p2.y);\n    }\n}"],"sourceRoot":""}